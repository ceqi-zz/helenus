package com.ceqi.footballBettingRecommendation.server.machineLearningModule;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;

import org.apache.mahout.classifier.sgd.CrossFoldLearner;

import com.ceqi.footballBettingRecommendation.server.HTTPRequest;
import com.ceqi.footballBettingRecommendation.server.features.EPLFeatures;
import com.ceqi.footballBettingRecommendation.server.features.EPLTeams;
import com.ceqi.footballBettingRecommendation.server.json.Event;
import com.ceqi.footballBettingRecommendation.server.json.MatchOfTheDayJson;
import com.ceqi.footballBettingRecommendation.server.json.ResultElmts;
import com.google.gwt.thirdparty.guava.common.base.Splitter;

/**
 * 
 *
 */

public final class CopyOfPrediction {
	private static String Y = "Y";
	private static String N = "N";

	private static CopyOfPrediction predictionIns = null;

	private ArrayList<Double> scores = new ArrayList<Double>();
	private ArrayList<Integer> rows = new ArrayList<Integer>();
	private ArrayList<Integer> cols = new ArrayList<Integer>();
	private ArrayList<String> games = new ArrayList<String>();

	/**
	 * Record the row position of the team's prediction score in the table. <br />
	 * Why no column position of the team score? homeTeam column is always at 1,
	 * awayTeam at 2 <br />
	 * This map is set up in isHomeMap method. <br />
	 */
	private HashMap<EPLTeams, Integer> teamPosRowMap = new HashMap<EPLTeams, Integer>();
	private LinkedHashMap<String, EPLTeams> teamsMap = new LinkedHashMap<String, EPLTeams>();
	// isHomeMap keeps 20 instinct teams isHome info
	private HashMap<EPLTeams, String> isHomeMap = new HashMap<EPLTeams, String>();

	/**
	 * fields used by the ML algorithm
	 * 
	 */
	private List<String> localDatasets = new ArrayList<String>();
	private List<EPLFeatures> features = new ArrayList<EPLFeatures>();

	private CopyOfPrediction() {
		/**
		 * dummy data
		 */
		// games.add("Arsenal v Man Utd");
		// games.add("Chelsea v Stoke");
		//
		// scores.add(0.42);
		// scores.add(0.70);
		// scores.add(0.71);
		// scores.add(0.30);
		//
		// rows.add(1);
		// cols.add(1);
		//
		// rows.add(1);
		// cols.add(2);
		//
		// rows.add(2);
		// cols.add(1);
		//
		// rows.add(2);
		// cols.add(2);
		initEPLTeamsMap();

	}

	public static CopyOfPrediction getPredictionIns() {
		if (predictionIns == null)
			return new CopyOfPrediction();
		else
			return predictionIns;
	}

	// betfair string ( which is not consistent with footballdata.co.uk string)
	// -> EPLTeams enum teamStrToEnum
	private void initEPLTeamsMap() {
		teamsMap.put("Chelsea", EPLTeams.CHELSEA);
		teamsMap.put("Sunderland", EPLTeams.SUNDERLAND);
		teamsMap.put("Everton", EPLTeams.EVERTON);
		teamsMap.put("Leicester", EPLTeams.LEICESTER);
		teamsMap.put("Man Utd", EPLTeams.MANUNITED);
		teamsMap.put("Norwich", EPLTeams.NORWICH);
		teamsMap.put("Southampton", EPLTeams.SOUTHAMPTON);
		teamsMap.put("Tottenham", EPLTeams.TOTTENHAM);
		teamsMap.put("Stoke", EPLTeams.STOKE);
		teamsMap.put("C Palace", EPLTeams.CRYSTALPALACE);
		teamsMap.put("West Brom", EPLTeams.WESTBROM);
		teamsMap.put("Bournemouth", EPLTeams.BOURNEMOUTH);
		teamsMap.put("Newcastle", EPLTeams.NEWCASTLE);
		teamsMap.put("Aston Villa", EPLTeams.ASTONVILLA);
		teamsMap.put("Watford", EPLTeams.WATFORD);
		teamsMap.put("Liverpool", EPLTeams.LIVERPOOL);
		teamsMap.put("Swansea", EPLTeams.SWANSEA);
		teamsMap.put("West Ham", EPLTeams.WESTHAM);
		teamsMap.put("Arsenal", EPLTeams.ARSENAL);
		teamsMap.put("Man City", EPLTeams.MANCITY);

	}

	/**
	 * Clear the 4 lists before initialisation(maps setup). <br />
	 * because this method will be called by a scheduled task.<br />
	 * Initialise the map fields
	 */
	public void init() {
		clearLists();
		fetchGames();
		initMaps();

	}

	/**
	 * a scheduled task to generatePredictions.
	 */
	public void generatePredictions() {
		algoSetup();

		// all 15-16 season's teams are ordered
		LinkedHashMap<String, EPLTeams> teamMap1516 = teamsMap;
		for (EPLTeams teamEnum : teamMap1516.values()) {
			String team = teamEnum.toString();
			Helenus helenus = new Helenus(localDatasets, teamEnum, features, 3);

			if (helenus.getExamples().size() < 30) {
				continue;
			}
			helenus.train();
			if (helenus.getLearnerAuc() < 0.65) {
				continue;
			}
			helenus.dissect();
			CrossFoldLearner classifier;
			double score = 0.50;
			while (score == 0.50) {
				try {
					helenus.createModel(team);
					classifier = helenus.getModel();
				} catch (IOException e) {
					throw new RuntimeException("Error reading model..");
				}

				Instance instance = new Instance(teamEnum, localDatasets, 3,
						features);
				// team win score
				score = classifier.classifyScalar(instance.asVector());
			}
			rows.add(getRow(teamEnum));
			cols.add(getCol(teamEnum));
			scores.add(score);
		}

	}

	private void clearLists() {
		games.clear();
		rows.clear();
		cols.clear();
		scores.clear();
	}

	/**
	 * Get game fixture from betfair.
	 * 
	 * @return a list of games.
	 */
	private ArrayList<String> fetchGames() {

		ArrayList<Event> eventsList = getEvents();

		sortEventsByDate(eventsList);
		for (int i = 0; i < eventsList.size(); i++) {
			Event evt = eventsList.get(i);
			if (isGame(evt)) {
				games.add(evt.getName());
			}
		}

		// for (String game : games) {
		// System.out.print(game + " ");
		// }
		// System.out.println();

		return games;
	}

	/**
	 * Set up isHomeMap: it records info that if teams' next game is going to
	 * play at home or not.<br />
	 * 
	 * Also, this method will set up the teamPosRowMap
	 * 
	 * Why do it in this way? ML models can only predict next game the teams are
	 * going to play.There are 20 teams in EPL (English Premier League)
	 * 
	 * @return
	 */
	private void initMaps() {
		ArrayList<String> gameList = getGames();
		Splitter onV = Splitter.on(" v ");

		for (int i = 0; i < gameList.size(); i++) {
			String gameName = gameList.get(i);
			List<String> twoTeamList = onV.splitToList(gameName);
			String homeTeam = twoTeamList.get(0);
			String awayTeam = twoTeamList.get(1);
			EPLTeams homeTeamEnum = teamsMap.get(homeTeam);
			EPLTeams awayTeamEnum = teamsMap.get(awayTeam);
			if (isHomeMap.size() < 20) {
				// distinct homeTeamEnum
				if (!isHomeMap.containsKey(homeTeamEnum)) {
					isHomeMap.put(teamStrToEnum(homeTeam), Y);
					this.teamPosRowMap.put(teamStrToEnum(homeTeam), i + 1);
				}
			} else {
				break;
			}
			if (isHomeMap.size() < 20) {
				// distinct awayTeamEnum
				if (!isHomeMap.containsKey(awayTeamEnum)) {
					isHomeMap.put(teamStrToEnum(awayTeam), N);
					this.teamPosRowMap.put(teamStrToEnum(awayTeam), i + 1);
				}
			} else {
				break;
			}

		}

	}

	private EPLTeams teamStrToEnum(String homeTeam) {
		return teamsMap.get(homeTeam);
	}

	private int getRow(EPLTeams teamName) {

		return teamPosRowMap.get(teamName);

	}

	/**
	 * homeTeam column is always at 1, awayTeam at 2
	 * 
	 * @param teamName
	 * @return
	 */
	private int getCol(EPLTeams teamName) {

		if (isHomeMap.get(teamName).equals(Y)) {
			return 1;
		}
		return 2;
	}

	/*
	 * ML algo simple setup
	 */

	private void algoSetup() {
		setLocalDatasets();
		setFeatures();
	}

	private void setLocalDatasets() {

		localDatasets.add("1112E0.csv");
		localDatasets.add("1213E0.csv");
		localDatasets.add("1314E0.csv");
		localDatasets.add("1415E0.csv");

	}

	private void setFeatures() {
		features.add(EPLFeatures.FTRESULTS);
		features.add(EPLFeatures.ISHOME);
		features.add(EPLFeatures.AVGGOALS);
		features.add(EPLFeatures.AVGPOINTS);
		features.add(EPLFeatures.CARDS);
		features.add(EPLFeatures.CORNERS);
		features.add(EPLFeatures.FOULS);
		features.add(EPLFeatures.SHOTS);
		features.add(EPLFeatures.SHOTS_ON_TARGET);
		features.add(EPLFeatures.OP_AVGGOALS);
		features.add(EPLFeatures.OP_AVGPOINTS);
		features.add(EPLFeatures.OP_CARDS);
		features.add(EPLFeatures.OP_CORNERS);
		features.add(EPLFeatures.OP_FOULS);
		features.add(EPLFeatures.OP_SHOTS);
		features.add(EPLFeatures.OP_SHOTS_ON_TARGET);
	}

	/*
	 * methods used by fetchGames
	 */

	public ArrayList<Event> getEvents() {
		ArrayList<Event> eventList = new ArrayList<Event>();
		try {
			HTTPRequest httpRequest = HTTPRequest.getHTTPRequestInstance();
			httpRequest.login();
			MatchOfTheDayJson json;
			json = httpRequest.post();
			ResultElmts[] results = json.getResultElmts();
			for (int i = 0; i < results.length; i++) {
				eventList.add(results[i].getEvent());
			}
		} catch (IOException e) {

			e.printStackTrace();
		}
		return eventList;

	}

	public void sortEventsByDate(ArrayList<Event> eventList) {
		Collections.sort(eventList);
		Collections.reverse(eventList);
	}

	public boolean isGame(Event evt) {
		String regex = "^[a-zA-Z ]{5,11} v [a-zA-Z ]{5,11}$";
		if (evt.getName().matches(regex)) {
			return true;
		} else {
			return false;
		}
	}

	/*
	 * Getters
	 */

	public ArrayList<String> getGames() {
		return games;
	}

	public ArrayList<Double> getScores() {
		return scores;
	}

	public ArrayList<Integer> getRows() {
		return rows;
	}

	public ArrayList<Integer> getCols() {
		return cols;
	}

	public HashMap<EPLTeams, String> getIsHomeMap() {
		return isHomeMap;
	}

}
